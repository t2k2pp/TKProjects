"""
動画フレーム抽出アプリケーション
- モード1: マウスカーソル程度の小さな変化は無視し、実質的な動きのあるフレームを抽出
- モード2: 指定した時間間隔で定期的にフレームを抽出
- tkinterベースのUI
- サンプリングタイミング指定可能
- 出力画像サイズをカスタマイズ可能
"""

import os
import cv2
import numpy as np
import tkinter as tk
from tkinter import filedialog, ttk, messagebox
from skimage.metrics import structural_similarity as ssim
from threading import Thread
from PIL import Image, ImageTk
import time
from datetime import timedelta
import math # 追加

class VideoFrameExtractor:
    def __init__(self, video_path=None, output_dir=None,
                 extraction_mode='change', # 追加: 'change' or 'interval'
                 diff_threshold=0.05, min_area_threshold=500,
                 blur_size=5, sample_interval=1.0, # デフォルトを1秒に変更
                 resize_output=False,
                 output_width=None, output_height=None):
        """
        動画フレーム抽出のメインクラス

        Parameters:
        -----------
        video_path : str
            入力動画ファイルのパス
        output_dir : str
            出力フレームを保存するディレクトリ
        extraction_mode : str
            抽出モード ('change': 変化検出, 'interval': 時間間隔)
        diff_threshold : float
            フレーム間の差分閾値 (0.0～1.0) - 変化検出モード用
        min_area_threshold : int
            有意な変化と判断する最小領域サイズ (px^2) - 変化検出モード用
        blur_size : int
            ノイズ除去用ブラーのサイズ - 変化検出モード用
        sample_interval : float
            サンプリング間隔（秒）。0より大きい値が必要。
        resize_output : bool
            出力サイズ変更フラグ
        output_width : int
            出力画像の幅
        output_height : int
            出力画像の高さ
        """
        self.video_path = video_path
        self.output_dir = output_dir
        self.extraction_mode = extraction_mode # 追加
        self.diff_threshold = diff_threshold
        self.min_area_threshold = min_area_threshold
        self.blur_size = blur_size
        # sample_intervalは常に1フレーム以上の間隔を持つように調整
        self.sample_interval = max(0.01, sample_interval) # 0秒以下は0.01秒に
        self.resize_output = resize_output
        self.output_width = output_width
        self.output_height = output_height

        # 処理状態
        self.is_processing = False
        self.stop_requested = False
        self.current_frame_index = 0 # フレーム番号をインデックスとして扱う
        self.total_frames = 0
        self.saved_frames = 0
        self.video_duration = 0
        self.current_time = 0
        self.fps = 0 # FPSを保持

        # コールバック関数
        self.progress_callback = None
        self.completion_callback = None

    def set_callbacks(self, progress_callback=None, completion_callback=None):
        """コールバック関数を設定"""
        self.progress_callback = progress_callback
        self.completion_callback = completion_callback

    def extract_frames(self):
        """動画からフレームを抽出する"""
        if not self.video_path or not self.output_dir:
            if self.completion_callback:
                self.completion_callback(False, "入力動画または出力ディレクトリが指定されていません")
            return False

        # 出力ディレクトリの確認
        if not os.path.exists(self.output_dir):
            try:
                os.makedirs(self.output_dir)
            except Exception as e:
                 if self.completion_callback:
                    self.completion_callback(False, f"出力ディレクトリの作成に失敗しました: {e}")
                 return False

        # 動画の読み込み
        cap = cv2.VideoCapture(self.video_path)
        if not cap.isOpened():
            if self.completion_callback:
                self.completion_callback(False, "動画ファイルを開けませんでした")
            return False

        # 動画情報の取得
        self.total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        self.fps = cap.get(cv2.CAP_PROP_FPS)
        if self.fps <= 0 or self.total_frames <= 0:
            cap.release()
            if self.completion_callback:
                self.completion_callback(False, "動画情報（FPSまたはフレーム数）を取得できませんでした")
            return False

        self.video_duration = self.total_frames / self.fps
        # sample_interval（秒）からフレーム間隔を計算
        frame_interval = max(1, int(math.ceil(self.fps * self.sample_interval))) # 切り上げで計算

        # 初期フレーム読み込み (変化検出モード用)
        prev_frame_gray = None
        if self.extraction_mode == 'change':
            ret, prev_frame = cap.read()
            if not ret:
                cap.release()
                if self.completion_callback:
                    self.completion_callback(False, "動画から最初のフレームを読み込めませんでした")
                return False
            prev_frame_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)
            prev_frame_gray = cv2.GaussianBlur(prev_frame_gray, (self.blur_size, self.blur_size), 0)
            # 最初のフレームは常に保存しない（比較対象としてのみ使用）
            self.current_frame_index = 1 # 最初のフレームを読んだのでインデックスを1に
            cap.set(cv2.CAP_PROP_POS_FRAMES, self.current_frame_index) # 次のフレームから開始
        else:
             self.current_frame_index = 0 # インターバルモードは0から

        self.saved_frames = 0
        self.is_processing = True
        self.stop_requested = False
        next_save_frame_index = 0 # インターバルモードで次に保存するフレームのインデックス

        while self.is_processing and not self.stop_requested:
            ret, current_frame = cap.read()
            if not ret:
                break # 動画の終端

            self.current_time = self.current_frame_index / self.fps

            should_save = False
            process_this_frame = False

            # --- フレームを処理・保存するかどうかの判定 ---
            if self.extraction_mode == 'interval':
                # 時間間隔モード: 指定されたフレーム間隔に達したか
                if self.current_frame_index >= next_save_frame_index:
                    should_save = True
                    next_save_frame_index += frame_interval # 次の保存フレームインデックスを更新
                process_this_frame = should_save # 保存する場合のみ処理
            elif self.extraction_mode == 'change':
                # 変化検出モード: 指定間隔ごと、かつ変化があるか
                # sample_intervalごとにチェック
                if self.current_frame_index % frame_interval == 0:
                   process_this_frame = True # このフレームは変化チェック対象

            # --- フレーム処理（必要な場合） ---
            if process_this_frame and self.extraction_mode == 'change':
                 # 現在のフレームをグレースケールに変換し、ブラー処理
                current_frame_gray = cv2.cvtColor(current_frame, cv2.COLOR_BGR2GRAY)
                current_frame_gray = cv2.GaussianBlur(current_frame_gray, (self.blur_size, self.blur_size), 0)

                # フレーム間の差分を計算（SSIM）
                try:
                    similarity_score, diff = ssim(prev_frame_gray, current_frame_gray, full=True)
                    diff = (diff * 255).astype("uint8")
                    thresh = cv2.threshold(diff, 127, 255, cv2.THRESH_BINARY_INV)[1]
                    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                    significant_change = False
                    for contour in contours:
                        if cv2.contourArea(contour) > self.min_area_threshold:
                            significant_change = True
                            break

                    # 類似度が閾値以下かつ有意な変化領域があれば保存フラグを立てる
                    if 1.0 - similarity_score > self.diff_threshold and significant_change:
                        should_save = True
                except ValueError as e:
                    # SSIM計算でエラーが発生することがある (例: 画像サイズが小さすぎる)
                    print(f"フレーム {self.current_frame_index} のSSIM計算中にエラー: {e}")
                    # エラーが発生した場合、このフレームの比較はスキップ
                    pass


                # 現在のフレームを前フレームとして更新
                prev_frame_gray = current_frame_gray

            # --- フレーム保存（必要な場合） ---
            if should_save:
                # 必要に応じてリサイズ
                if self.resize_output and self.output_width and self.output_height:
                    output_frame = cv2.resize(current_frame, (self.output_width, self.output_height))
                else:
                    output_frame = current_frame

                # ファイル名に時間情報を含める
                time_str = str(timedelta(seconds=int(self.current_time))).replace(':', '-')
                # ミリ秒も追加 (小数点以下3桁)
                ms_str = f"{self.current_time - int(self.current_time):.3f}"[2:]
                output_path = f"{self.output_dir}/frame_{self.current_frame_index:06d}_{time_str}-{ms_str}.jpg"
                cv2.imwrite(output_path, output_frame)
                self.saved_frames += 1

            # 進捗通知 (負荷軽減のため間引く)
            if self.progress_callback and self.current_frame_index % 10 == 0:
                self.progress_callback(self.current_frame_index, self.total_frames, self.current_time, self.video_duration, self.saved_frames)

            self.current_frame_index += 1 # 次のフレームへ

        cap.release()
        self.is_processing = False

        # 最終進捗通知
        if self.progress_callback:
             self.progress_callback(self.current_frame_index, self.total_frames, self.current_time, self.video_duration, self.saved_frames)

        # 処理完了通知
        if self.completion_callback:
            final_frame_count = self.current_frame_index # 処理したフレーム数
            if self.stop_requested:
                self.completion_callback(False, "処理が中断されました")
            else:
                self.completion_callback(True, f"処理完了: 合計{final_frame_count}フレーム処理し、{self.saved_frames}フレームを抽出しました")

        return not self.stop_requested

    def start_extraction(self):
        """別スレッドでフレーム抽出を開始"""
        if self.is_processing:
            return False

        extraction_thread = Thread(target=self.extract_frames)
        extraction_thread.daemon = True
        extraction_thread.start()
        return True

    def stop_extraction(self):
        """抽出処理の停止を要求"""
        self.stop_requested = True


class VideoFrameExtractorApp:
    def __init__(self, root):
        """
        アプリケーションのUIクラス

        Parameters:
        -----------
        root : tk.Tk
            tkinterのルートウィンドウ
        """
        self.root = root
        self.root.title("動画フレーム抽出ツール")
        self.root.geometry("800x750") # 少し縦長に
        self.root.resizable(True, True)

        # スタイル設定
        self.style = ttk.Style()
        self.style.configure("TButton", font=("Helvetica", 12))
        self.style.configure("TLabel", font=("Helvetica", 12))
        self.style.configure("TCheckbutton", font=("Helvetica", 12))
        self.style.configure("TRadiobutton", font=("Helvetica", 12)) # Radiobuttonスタイル追加

        # フレーム抽出クラス
        self.extractor = VideoFrameExtractor()

        # UI作成
        self.create_widgets()

        # 処理ステータス
        self.processing = False

    def create_widgets(self):
        """UIウィジェットの作成"""
        # メインフレーム
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- ファイル選択フレーム ---
        file_frame = ttk.LabelFrame(main_frame, text="ファイル選択", padding="10")
        file_frame.pack(fill=tk.X, pady=5)

        ttk.Label(file_frame, text="入力動画ファイル:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.video_path_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.video_path_var, width=50).grid(row=0, column=1, pady=5, padx=5, sticky=tk.EW)
        ttk.Button(file_frame, text="参照...", command=self.browse_video).grid(row=0, column=2, pady=5)
        file_frame.columnconfigure(1, weight=1) # Entryを伸縮させる

        ttk.Label(file_frame, text="出力フォルダ:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.output_dir_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.output_dir_var, width=50).grid(row=1, column=1, pady=5, padx=5, sticky=tk.EW)
        ttk.Button(file_frame, text="参照...", command=self.browse_output_dir).grid(row=1, column=2, pady=5)

        # --- 設定フレーム ---
        settings_frame = ttk.LabelFrame(main_frame, text="抽出設定", padding="10")
        settings_frame.pack(fill=tk.X, pady=5)
        settings_frame.columnconfigure(1, weight=1) # Scaleなどを伸縮させるため

        # --- 抽出モード選択 ---
        ttk.Label(settings_frame, text="抽出モード:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.mode_var = tk.StringVar(value="change") # デフォルトは変化検出
        mode_frame = ttk.Frame(settings_frame)
        mode_frame.grid(row=0, column=1, columnspan=3, sticky=tk.W, pady=5)
        ttk.Radiobutton(mode_frame, text="変化があったフレームを抽出", variable=self.mode_var, value="change", command=self.toggle_mode_settings).pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(mode_frame, text="指定時間間隔で抽出", variable=self.mode_var, value="interval", command=self.toggle_mode_settings).pack(side=tk.LEFT, padx=5)

        # --- 時間間隔設定 ---
        ttk.Label(settings_frame, text="抽出間隔 (秒):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.sample_interval_var = tk.DoubleVar(value=1.0) # デフォルト1秒
        self.interval_spinbox = ttk.Spinbox(settings_frame, from_=0.1, to=3600, increment=0.1, textvariable=self.sample_interval_var, width=10, format="%.1f")
        self.interval_spinbox.grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(settings_frame, text="(例: 0.5 = 0.5秒ごと)").grid(row=1, column=2, columnspan=2, sticky=tk.W, pady=5)

        # --- 変化検出設定 (モードによって有効/無効切り替え) ---
        self.change_settings_frame = ttk.Frame(settings_frame)
        self.change_settings_frame.grid(row=2, column=0, columnspan=4, sticky=tk.EW, pady=5)
        self.change_settings_frame.columnconfigure(1, weight=1)

        # 差分閾値
        self.threshold_label = ttk.Label(self.change_settings_frame, text="変化検出感度:")
        self.threshold_label.grid(row=0, column=0, sticky=tk.W, pady=5)
        self.threshold_var = tk.DoubleVar(value=0.05)
        # 修正: commandを追加してラベル更新関数を呼び出す
        self.threshold_scale = ttk.Scale(self.change_settings_frame, from_=0.01, to=0.2,
                                    variable=self.threshold_var, orient=tk.HORIZONTAL, length=200,
                                    command=self._update_threshold_label) # command追加
        self.threshold_scale.grid(row=0, column=1, sticky=tk.EW, pady=5, padx=5)
        # 修正: formatを削除し、初期テキストを設定
        self.threshold_value_label = ttk.Label(self.change_settings_frame, text=f"{self.threshold_var.get():.2f}")
        self.threshold_value_label.grid(row=0, column=2, sticky=tk.W, pady=5)
        self.threshold_desc_label = ttk.Label(self.change_settings_frame, text="(小さい値ほど敏感)")
        self.threshold_desc_label.grid(row=0, column=3, sticky=tk.W, pady=5)

        # 最小変化領域
        self.area_label = ttk.Label(self.change_settings_frame, text="最小変化領域:")
        self.area_label.grid(row=1, column=0, sticky=tk.W, pady=5)
        self.area_threshold_var = tk.IntVar(value=500)
        # 修正: commandを追加してラベル更新関数を呼び出す (整数なのでフォーマット不要だが念のため)
        self.area_scale = ttk.Scale(self.change_settings_frame, from_=100, to=2000,
                               variable=self.area_threshold_var, orient=tk.HORIZONTAL, length=200,
                               command=self._update_area_label) # command追加
        self.area_scale.grid(row=1, column=1, sticky=tk.EW, pady=5, padx=5)
        # 修正: textvariableの代わりにtextを使用
        self.area_value_label = ttk.Label(self.change_settings_frame, text=f"{self.area_threshold_var.get()}")
        self.area_value_label.grid(row=1, column=2, sticky=tk.W, pady=5)
        self.area_desc_label = ttk.Label(self.change_settings_frame, text="px² (大きい値ほど小さな変化を無視)")
        self.area_desc_label.grid(row=1, column=3, sticky=tk.W, pady=5)


        # --- 出力サイズ設定 ---
        size_frame = ttk.LabelFrame(main_frame, text="出力サイズ設定", padding="10")
        size_frame.pack(fill=tk.X, pady=5)

        self.resize_var = tk.BooleanVar(value=False)
        resize_check = ttk.Checkbutton(size_frame, text="出力サイズを変更する",
                                       variable=self.resize_var, command=self.toggle_resize_entry)
        resize_check.grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=5)

        ttk.Label(size_frame, text="幅:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.width_var = tk.IntVar(value=640)
        self.width_entry = ttk.Entry(size_frame, textvariable=self.width_var, width=10, state="disabled")
        self.width_entry.grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)

        ttk.Label(size_frame, text="高さ:").grid(row=1, column=2, sticky=tk.W, pady=5)
        self.height_var = tk.IntVar(value=480)
        self.height_entry = ttk.Entry(size_frame, textvariable=self.height_var, width=10, state="disabled")
        self.height_entry.grid(row=1, column=3, sticky=tk.W, pady=5, padx=5)

        # --- プレビューフレーム ---
        preview_frame = ttk.LabelFrame(main_frame, text="プレビューと進捗", padding="10")
        preview_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        self.preview_label = ttk.Label(preview_frame)
        self.preview_label.pack(pady=10)

        self.progress_var = tk.DoubleVar(value=0)
        self.progress_bar = ttk.Progressbar(preview_frame, variable=self.progress_var, maximum=100, length=700)
        self.progress_bar.pack(pady=10, fill=tk.X)

        self.progress_label = ttk.Label(preview_frame, text="準備完了")
        self.progress_label.pack(pady=5)

        # --- ボタンフレーム ---
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=10)

        self.start_button = ttk.Button(button_frame, text="抽出開始", command=self.start_extraction)
        self.start_button.pack(side=tk.LEFT, padx=5)

        self.stop_button = ttk.Button(button_frame, text="停止", command=self.stop_extraction, state="disabled")
        self.stop_button.pack(side=tk.LEFT, padx=5)

        self.quit_button = ttk.Button(button_frame, text="終了", command=self.root.destroy)
        self.quit_button.pack(side=tk.RIGHT, padx=5)

        # 初期状態設定
        self.toggle_mode_settings()
        self.update_preview(None)

    # 追加: 変化検出感度ラベル更新用メソッド
    def _update_threshold_label(self, value):
        """Scaleの値が変更されたときに感度ラベルのテキストを更新する"""
        self.threshold_value_label.config(text=f"{float(value):.2f}")

    # 追加: 最小変化領域ラベル更新用メソッド
    def _update_area_label(self, value):
        """Scaleの値が変更されたときに最小変化領域ラベルのテキストを更新する"""
        # IntVarなので整数に変換してから表示
        self.area_value_label.config(text=f"{int(float(value))}") # Scaleからはfloatで渡されることがあるため

    def browse_video(self):
        """動画ファイル選択ダイアログ"""
        file_path = filedialog.askopenfilename(
            title="動画ファイルを選択",
            filetypes=[
                ("動画ファイル", "*.mp4 *.avi *.mov *.mkv *.flv"),
                ("すべてのファイル", "*.*")
            ]
        )
        if file_path:
            self.video_path_var.set(file_path)
            self.load_video_thumbnail(file_path)

    def browse_output_dir(self):
        """出力フォルダ選択ダイアログ"""
        dir_path = filedialog.askdirectory(title="出力フォルダを選択")
        if dir_path:
            self.output_dir_var.set(dir_path)

    def toggle_resize_entry(self):
        """リサイズオプションの切り替え"""
        state = "normal" if self.resize_var.get() else "disabled"
        self.width_entry.config(state=state)
        self.height_entry.config(state=state)

    def toggle_mode_settings(self):
        """抽出モードに応じて設定項目の有効/無効を切り替え"""
        mode = self.mode_var.get()
        change_widgets = [
            self.threshold_label, self.threshold_scale, self.threshold_value_label, self.threshold_desc_label,
            self.area_label, self.area_scale, self.area_value_label, self.area_desc_label
        ]
        if mode == 'change':
            # 変化検出モード: 変化検出設定を有効化
            for widget in change_widgets:
                try:
                    widget.configure(state='normal')
                except tk.TclError: # Style適用済みなどでのエラーを無視
                    pass
            # 初期値を反映させるため、ラベル更新関数を呼ぶ
            self._update_threshold_label(self.threshold_var.get())
            self._update_area_label(self.area_threshold_var.get())

        elif mode == 'interval':
            # 時間間隔モード: 変化検出設定を無効化
            for widget in change_widgets:
                 try:
                    widget.configure(state='disabled')
                 except tk.TclError:
                     pass


    def load_video_thumbnail(self, video_path):
        """動画のサムネイルを読み込んで表示"""
        try:
            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                self.progress_label.config(text="エラー: 動画ファイルを開けません")
                self.update_preview(None)
                return

            ret, frame = cap.read()
            if ret:
                frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                h, w = frame_rgb.shape[:2]
                max_size = 300 # プレビューサイズ少し小さく
                if w > h:
                    new_w = max_size
                    new_h = int(h * max_size / w)
                else:
                    new_h = max_size
                    new_w = int(w * max_size / h)

                frame_resized = cv2.resize(frame_rgb, (new_w, new_h))
                img = Image.fromarray(frame_resized)
                img_tk = ImageTk.PhotoImage(image=img)

                self.preview_label.config(image=img_tk)
                self.preview_label.image = img_tk

                fps = cap.get(cv2.CAP_PROP_FPS)
                frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                duration = frame_count / fps if fps > 0 else 0

                self.progress_label.config(text=f"動画情報: {w}x{h}, {fps:.2f}fps, {frame_count}フレーム, {duration:.2f}秒")
            else:
                self.progress_label.config(text="エラー: 動画からフレームを読み込めません")
                self.update_preview(None)


            cap.release()
        except Exception as e:
            messagebox.showerror("エラー", f"サムネイル読み込みエラー: {str(e)}")
            self.progress_label.config(text="サムネイル読み込みエラー")
            self.update_preview(None) # エラー時はデフォルト表示に

    def update_preview(self, frame):
        """プレビュー画像の更新"""
        try:
            if frame is None:
                img = Image.new('RGB', (320, 240), color=(200, 200, 200)) # デフォルトサイズ
            else:
                frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                h, w = frame_rgb.shape[:2]
                max_size = 300
                if w > h:
                    new_w = max_size
                    new_h = int(h * max_size / w)
                else:
                    new_h = max_size
                    new_w = int(w * max_size / h)
                frame_resized = cv2.resize(frame_rgb, (new_w, new_h))
                img = Image.fromarray(frame_resized)

            img_tk = ImageTk.PhotoImage(image=img)
            self.preview_label.config(image=img_tk)
            self.preview_label.image = img_tk
        except Exception as e:
            # プレビュー更新中のエラーは無視しても良い場合が多い
            print(f"プレビュー更新エラー: {e}")


    def update_progress(self, current_frame, total_frames, current_time, total_time, saved_frames):
        """進捗状況の更新"""
        if total_frames > 0 and not self.stop_requested: # 停止要求後は更新しない
            # current_frameがtotal_framesを超える場合があるため、最大値を100にする
            progress = min(100, (current_frame / total_frames) * 100)
            self.progress_var.set(progress)

            time_str = str(timedelta(seconds=int(current_time))).split('.')[0]
            total_str = str(timedelta(seconds=int(total_time))).split('.')[0]

            self.progress_label.config(
                text=f"進捗: {current_frame}/{total_frames} フレーム ({progress:.1f}%), "
                     f"時間: {time_str}/{total_str}, 保存済み: {saved_frames}枚"
            )

            # プレビュー更新 (負荷軽減のため間引く & 停止要求時は行わない)
            if current_frame % 30 == 0: # 約1秒ごと (30fps想定)
                # プレビュー更新はメインスレッドで行う必要があるため、afterを使用
                self.root.after(10, self._update_preview_frame, current_frame)


    def _update_preview_frame(self, frame_index):
        """プレビュー用のフレームを読み込んで更新 (update_progressから呼ばれる)"""
        if self.processing and not self.stop_requested:
            try:
                # 毎回VideoCaptureを開くのは非効率なので、可能ならインスタンスを保持する方が良いが、
                # threading環境下での安全性と簡便性からここでは都度開く方式を維持
                cap = cv2.VideoCapture(self.video_path_var.get())
                if cap.isOpened():
                    cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
                    ret, frame = cap.read()
                    if ret:
                        self.update_preview(frame)
                    cap.release()
            except Exception as e:
                 print(f"プレビューフレーム読み込みエラー: {e}")


    def process_completed(self, success, message):
        """処理完了時のコールバック"""
        self.processing = False
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        # 処理完了/中断時に設定を有効に戻す (オプション機能を有効にする場合)
        # self.enable_settings()

        if success:
            messagebox.showinfo("完了", message)
        else:
            # 中断以外のエラーメッセージを表示
            if message != "処理が中断されました":
                 messagebox.showerror("エラーまたは中断", message)

        self.progress_label.config(text=message)
        # 成功時または中断されなかった場合のみプログレスバーを100%に
        if success and not self.extractor.stop_requested:
             self.progress_var.set(100)
        else:
            # 停止した場合などは現在の進捗を維持
            pass


    def start_extraction(self):
        """抽出処理の開始"""
        if not self.video_path_var.get():
            messagebox.showerror("エラー", "動画ファイルを選択してください")
            return

        if not self.output_dir_var.get():
            messagebox.showerror("エラー", "出力フォルダを選択してください")
            return

        output_dir = self.output_dir_var.get()
        if not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir)
            except Exception as e:
                messagebox.showerror("エラー", f"出力フォルダの作成に失敗しました: {str(e)}")
                return

        # sample_intervalが0以下でないかチェック
        try:
            interval_value = self.sample_interval_var.get()
            if interval_value <= 0:
                 messagebox.showerror("エラー", "抽出間隔は0より大きい値を指定してください。")
                 return
        except tk.TclError:
             messagebox.showerror("エラー", "抽出間隔に有効な数値を入力してください。")
             return


        # 設定の適用
        self.extractor = VideoFrameExtractor(
            video_path=self.video_path_var.get(),
            output_dir=output_dir,
            extraction_mode=self.mode_var.get(), # モードを追加
            diff_threshold=self.threshold_var.get(),
            min_area_threshold=self.area_threshold_var.get(),
            blur_size=5, # 固定値 (必要ならUIに追加)
            sample_interval=interval_value, # Spinboxから取得
            resize_output=self.resize_var.get(),
            output_width=self.width_var.get() if self.resize_var.get() else None,
            output_height=self.height_var.get() if self.resize_var.get() else None
        )

        self.extractor.set_callbacks(
            progress_callback=self.update_progress,
            completion_callback=self.process_completed
        )

        if self.extractor.start_extraction():
            self.processing = True
            self.start_button.config(state="disabled")
            self.stop_button.config(state="normal")
            self.progress_var.set(0)
            self.progress_label.config(text="処理を開始しています...")
            # 処理中は設定変更不可にする (オプション)
            # self.disable_settings()
        else:
            # start_extraction内でエラーが発生した場合 (スレッド開始前)
            # completion_callbackは呼ばれないので、ここでUIを元に戻す
            self.processing = False
            self.start_button.config(state="normal")
            self.stop_button.config(state="disabled")
            messagebox.showerror("エラー", "処理の開始に失敗しました")


    def stop_extraction(self):
        """抽出処理の停止"""
        if self.processing and self.extractor:
            self.extractor.stop_extraction()
            self.stop_button.config(state="disabled") # 停止ボタンは即座に無効化
            self.progress_label.config(text="停止処理中...")
            # 停止要求後、完了コールバックが呼ばれるのを待つ
            # 完了コールバック内で start_button が normal に戻される

    # (オプション) 処理中に設定を無効化/有効化する関数
    # def disable_settings(self):
    #     """処理中にUI設定項目を無効化する"""
    #     widgets_to_disable = []
    #     # ファイル選択フレーム
    #     for child in self.file_frame.winfo_children():
    #         widgets_to_disable.append(child)
    #     # 設定フレーム
    #     for child in self.settings_frame.winfo_children():
    #          # change_settings_frame 自体は無効化しない
    #         if child != self.change_settings_frame:
    #             widgets_to_disable.append(child)
    #     # change_settings_frame の中身
    #     for child in self.change_settings_frame.winfo_children():
    #         widgets_to_disable.append(child)
    #     # サイズ設定フレーム
    #     for child in self.size_frame.winfo_children():
    #         widgets_to_disable.append(child)

    #     for widget in widgets_to_disable:
    #         try:
    #             # 'state' オプションを持たないウィジェットもあるためチェック
    #             if 'state' in widget.configure():
    #                 widget.configure(state='disabled')
    #         except tk.TclError:
    #             pass # configureできないウィジェットは無視

    # def enable_settings(self):
    #     """処理完了/中断時にUI設定項目を有効化する"""
    #     widgets_to_enable = []
    #     # ファイル選択フレーム
    #     for child in self.file_frame.winfo_children():
    #         widgets_to_enable.append(child)
    #     # 設定フレーム
    #     for child in self.settings_frame.winfo_children():
    #         if child != self.change_settings_frame:
    #             widgets_to_enable.append(child)
    #     # change_settings_frame の中身
    #     for child in self.change_settings_frame.winfo_children():
    #         widgets_to_enable.append(child)
    #     # サイズ設定フレーム
    #     for child in self.size_frame.winfo_children():
    #         widgets_to_enable.append(child)

    #     for widget in widgets_to_enable:
    #         try:
    #             if 'state' in widget.configure():
    #                 widget.configure(state='normal')
    #         except tk.TclError:
    #             pass

    #     # 個別に状態管理が必要なものを再設定
    #     self.toggle_resize_entry()
    #     self.toggle_mode_settings()


def main():
    """メインエントリーポイント"""
    root = tk.Tk()
    app = VideoFrameExtractorApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()
